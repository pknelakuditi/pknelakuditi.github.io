{"name":"pknelakuditi.GitHub.io","tagline":"","body":"##Breadth First Search : \r\n\r\n* **using QUEUE** :\r\n\r\n```java\r\nq.add(start);\r\nvisited[start] = true;\r\n\t\twhile (!q.isEmpty()) {\r\n\t\t\tint temp = q.remove();\r\n\t\t\tfor (int i = 0; i < graph.get(temp).size(); i++) {\r\n\t\t\t\tif (!visited[i]) {\r\n\t\t\t\t\tvisited[i] = true;\r\n\t\t\t\t\tq.add(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n``` \t\t\r\n\r\n##Depth First Search\r\n\r\n* **using stack** :\r\n\r\n```java\r\n\r\npublic static void dfs(ArrayList<ArrayList<Integer>> graph,int start){\r\nq.add(start);\r\nvisited[start] = true;\r\n\t\twhile(!s.isEmpty()){\r\n\t\t\tint temp=s.pop();\r\n\t\t\tArrayList<Integer> neighbours=graph.get(temp);\r\n\t\t\tfor(int n:neighbours){\r\n\t\t\t\tif(!visited[n]){\r\n\t\t\t\t\ts.add(n);\r\n\t\t\t\t\tvisited[n]=true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n}\r\n\r\n```\r\n\r\n##Dijkstra's Algorithm \r\n\r\n\r\n```java  \r\n\r\npublic static int dijkstras(Vertex[] graph, int source, int destination) {\r\n        boolean[] visited =new boolean[graph.length];\r\n\t\tVertex current = graph[source];\r\n\t\t\r\n\t\tPriorityQueue<Vertex> pq = new PriorityQueue<Vertex>();\r\n\t\t//intially minDistance for each vertex would be Integer.MAXVALUE make start distance as zero\r\n        current.minDistance=0;\r\n\t\tpq.add(current);\r\n\t\twhile (!pq.isEmpty()) {\r\n\t\t\tcurrent = pq.remove();\r\n\t\t\tif (current.id == destination) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif(visited[current.id]){\r\n\t\t\t\tcontinue;\r\n\t\t\t}else{\r\n\t\t\t\tvisited[current.id]=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//updating all the unvisited new neighbour values  and insert in pq\r\n\t\t\tfor (Edge e : current.neighbors) {\r\n\t\t\t\tif((visited[e.end])){continue;}\r\n\t\t\t\tVertex end = graph[e.end];\r\n\t\t\t\tint distance = e.distance;\r\n\t\t\t\tint newMin = distance + current.minDistance;\r\n\t\t\t\tif (newMin < end.minDistance  ) {\r\n\t\t\t\t\tend.minDistance = newMin;\r\n\t\t\t\t\tpq.add(end);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn graph[destination].minDistance;\t\t\r\n\t\t\r\n\t}\r\n```\r\n\r\n##Prim's Algorithm\r\n\r\n```java\r\n\tprivate static int PrimsAlgorithm(Vertex[] graph, int source) {\r\n\t\tPriorityQueue<Edge> pq=new PriorityQueue<Edge>();\r\n\t\tboolean[] visited=new boolean[graph.length];\r\n\t\r\n\t\tint cost=0;\r\n\t\t\r\n\t\tvisited[source]=true;\r\n\t\tfor(Edge e:graph[source].neighbors){\r\n\t\t\tpq.add(e);\r\n\t\t}\r\n\t\t\r\n\t\twhile(!pq.isEmpty()){\r\n\t\t\tEdge current=pq.remove();\r\n\t\t\r\n\t\t\tif(visited[current.edge]){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvisited[current.edge]=true;\r\n\t\t\tcost=cost+current.cost;\r\n\t\t\t//adding all the unvisited neoghbours into the priority pq\r\n\t\t\tfor(Edge e:graph[current.edge].neighbors){\r\n\t\t\t\tif(visited[e.edge]){\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tpq.add(e);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn cost;\r\n\t}\r\n```\r\n##Kruskal's algo : \r\ncomparable on the cost of edge and put it pq and add the edges into MST when only it results in union of two different sets.\r\n\r\ntaking care of disjoint sets:\r\n```java\r\npublic static class DisjointSets {\r\n\t\tint[] parents;\r\n\r\n\t\tpublic DisjointSets(int size) {\r\n\t\t\tparents = new int[size];\r\n\t\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\t\tparents[i] = i;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tpublic int find(int x) {\r\n\t\t\tif (parents[x] == x) {\r\n                return x;\r\n\t\t\t}else{\r\n\t\t\t\tparents[x]=find(parents[x]);\r\n\t\t\t\treturn parents[x];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic void union(int x,int y){\r\n\t\t\tparents[find(x)]=find(y);\r\n\t\t}\r\n\r\n\t}\r\n```\r\nadd all the edges to pq and send it as parameter for function\r\n```java\r\nprivate static int kruskals(PriorityQueue<Edge> pq, int v) {\r\n\t\tDisjointSets ds=new DisjointSets(v);\r\n\t\tEdge current;\r\n\t\tint components=v;\r\n\t\tint cost=0;\r\n\t\twhile(!pq.isEmpty()){\r\n\t\t\tcurrent=pq.remove();\r\n\t\t\tif(ds.find(current.edge)==ds.find(current.oEdge)){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tcomponents--;\r\n\t\t\tds.union(current.edge,current.oEdge);\r\n\t\t\tcost+=current.cost;\r\n\t\t}\r\n\t\tif(components>1){\r\n\t\t\treturn -1;\r\n\t\t}else{\r\n\t\t\treturn cost;\r\n\t\t}\r\n\t\t\r\n\t}\r\n```\r\n##Range Minimum Query (RMQ)\r\n\r\ndescription: on arrays to find the position of an element with the minimum value between two specified indices.\r\n\r\nAlgo:\r\n preprocess sqrt(N) segment minimums\r\n range given then 2 half participated and remaining all full participated segments.\r\n* preprocess: O(N)\r\n* range query : O(sqrt(N))\r\n\r\nwhen update(i,X)\r\nthen calculate min for inserted segment O(sqrt(N))\r\n\r\n##Least commom ansestor \r\n-----------------------\r\ndesc : can be reduced to a restricted version of an RMQ problem, in which consecutive array elements differ by exactly 1.\r\n\r\npreprocessing:O(N)\r\ndivide into sqrt(h) height segments make each element in the segment point to the least ancestor in the next height segment.\r\nquery:O(log(N))\r\nlca(a,b)\r\nthen check the height segment of the nodes and make min of them jump segmnts till it reaches the the other by moving up to its parents similar to previous problem then \r\n\r\nif both parent for next height segment values are same then start moving up the in the same height segment one after another by comparing both of their parents \r\nelse move both pointers to next height segment to their resoectice parents\r\n\r\n\r\nother algo : write inorder of the tree and find minimum in range of tree index [a,b] . \r\n\r\ntry coding it\r\n```java\r\nstruct Node *findLCA(struct Node* root, int n1, int n2)\r\n{\r\n   \r\n   if (root == NULL) return NULL; \r\n   if (root->key == n1 || root->key == n2)\r\n        return root;\r\n    \r\n    Node *left_lca  = findLCA(root->left, n1, n2);\r\n    Node *right_lca = findLCA(root->right, n1, n2);\r\n \r\n   if (left_lca && right_lca)  return root;\r\n \r\n     return (left_lca != NULL)? left_lca: right_lca;\r\n}\r\n```\r\n\r\nproblems:\r\nhttp://www.spoj.com/problems/LCASQ/\r\nhttp://www.spoj.com/problems/RMQSQ/\r\nhttp://www.spoj.com/problems/LCA/\r\n\r\n\r\nresource:\r\nhttp://help.topcoder.com/data-science/competing-in-algorithm-challenges/algorithm-tutorials/range-minimum-query-and-lowest-common-ancestor/\r\n\r\n##Range Sum Query:\r\n\r\na[] =original array\r\nb[] =cumative sum array\r\n\r\nget an array which have sum of all the b[i]=b[i-1]+a[i]\r\n\r\n\r\n* preprocessing : o(N) \r\n* query: b[j]-b[i-1]  o(1)\r\n* update: o(N)\r\n\r\ncan be done better by using:\r\n \t**Fenwick tree or binary indexed tree**\r\n \t\r\n \tleast significant bit of x = x & -x\r\n \t-x = !x + 1 \r\n \t\r\n \t\r\n```java\t\r\nclass BIT {\r\n\tint[] tree;\r\n\tpublic BIT(int n) {\r\n\t\tthis.tree = new int[n];\r\n\t}\r\n\tint lsb(int x) {\r\n\t\treturn x & -x;\r\n\t}\r\n\tvoid update(int i, int x) {\r\n\t\twhile (i <= tree.length-1) {\r\n\t\t\ttree[i] += x;\r\n\t\t\ti += lsb(i);\r\n\t\t}\r\n\t}\r\n\tint query(int i) {\r\n\t\tint sum = 0;\r\n\t\twhile (i > 0) {\r\n\t\t\tsum += tree[i];\r\n\t\t\ti -= lsb(i);\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n}\r\n```\r\n \t\r\nhttp://community.topcoder.com/tc?module=Static&d1=tutorials&d2=binaryIndexedTrees\r\nhttp://pdf.aminer.org/001/073/976/a_new_data_structure_for_cumulative_frequency_tables.pdf  \r\n\r\n##Dynamic Programming\r\noptimization approach that transforms a complex problem into a sequence of simpler problems.\r\n\r\n* **Longest Increasing subsequence** :\r\n```java\r\nprivate static int lis(int[] arr) {\r\n\t\tint max=1;\r\n\t\tmem=new int[arr.length];\r\n\t    Arrays.fill(mem, 1);\r\n\t    for(int i=1;i<arr.length;i++){\r\n\t    \tfor(int j=0;j<i;j++){\r\n\t    \t\tif(arr[j]<arr[i] && mem[i]<mem[j]+1){\r\n\t    \t\t\tmem[i]=mem[j]+1;\r\n\t    \t\t}\r\n\t    \t}\r\n\t    \tif(max<mem[i])max=mem[i];\r\n\t    }\r\n\t\t\r\n\t\treturn max;\r\n\t}\r\n```\r\n\r\n* **Longest common subsequence** :\r\n if X(i) = Y(j)\r\n D(i,j) =D( i-1,j-1 )+ 1\r\n else :\r\n D(i,j) =Max(D( i-1,j ),D( i,j-1 ))\r\n Base cases:\r\n D( i,0 )=D( 0,j )=0\r\n \r\n ```java\r\n private static int lcs(String a, String b) {\r\n\t\tmem = new int[a.length() + 1][b.length() + 1];\r\n\t\t\r\n\t\tfor (int i = 1; i <= a.length(); i++) {\r\n\t\t\tfor (int j = 1; j <= b.length(); j++) {\r\n\t\t\t\tif (a.charAt(i - 1) == b.charAt(j-1)) {\r\n\t\t\t\t\tmem[i][j] = mem[i - 1][j - 1] + 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmem[i][j] = Math.max(mem[i][j - 1], mem[i - 1][j]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn mem[a.length()][b.length()];\r\n\t}\r\n \r\n ```\r\n \r\n* **Palindrome Min Insertions**:\r\n minimum number of characters that need to be inserted to make it a palindrome\r\n   1. gap increasing\r\n \tD(i,j)=1+min( D(i+1,j),D(i,j-1) )\t\tif str[i]!=str[j]\r\n \tD(i,j)=D(i+1,j-1)\t\t\t\t\t\tif str[i]==str[j]\r\n \t\r\n \t```java\r\n \t\r\n\tprivate static int minInsertPalindrome(String string) {\r\n\t\tfor(int gap=1;gap<string.length();gap++){\t\t\t\r\n\t\t\tfor(int i=0,j=gap;j<string.length();i++,j++){\r\n\t\t\t\t\ta[i][j] = (string.charAt(i) == string.charAt(j)) ? a[i + 1][j - 1]: Math.min(a[i][j - 1], a[i + 1][j]) + 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn a[0][string.length()-1];\r\n\t}\r\n \t```\r\n \tTime complexity: O(N^2)\r\n\tAuxiliary Space: O(N^2)\r\n \t\r\n   2.  return string.length()-lcs(string,string.reverse())\r\n   \r\n* **Longest Subsequence Without Repetition** :\r\n```java\r\nstatic int[] mem = new int[256];\r\n\r\n\tprivate static int longestSub(String a) {\r\n\t\tArrays.fill(mem, -1);\r\n\t\tint pIndex;\r\n\t\tint current = 1;\r\n\t\tint max=1;\r\n\r\n\t\tmem[a.charAt(0)] = 0;\r\n\t\tfor (int i = 1; i < a.length(); i++) {\r\n\t\t\tpIndex=mem[a.charAt(i)];\r\n\t\t\t//character not visited previously or it is not a part of Non repeating sequence\r\n           if(pIndex==-1 || i-current>pIndex){\r\n        \t   current++;\r\n           }else{\r\n        \t   //update max value if previous current value is greater than max till then\r\n        \t   if(current>max){\r\n        \t\t   max=current;\r\n        \t   }\r\n        \t   current=i-pIndex;\r\n        \t   \r\n           }\r\n           mem[a.charAt(i)]=i;\r\n\t\t}\r\n\t\t if(current>max){\r\n  \t\t   max=current;\r\n\t\t}\r\n\r\n\t\treturn max;\r\n\t}\r\n```\r\n\r\n\r\n* **Edit distance**:\r\nT(m, n) = T(m-1, n-1) + T(m, n-1) + T(m-1, n) + C\r\n\r\ntime complexity: O(mn)\r\nspace complexity: O(mn)\r\n\r\n* **Longest common subsequence** :\r\n```java\r\n```\r\n\r\n### TopCoder DP :\r\n* **ZigZag Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4493&pm=1259\r\n* **BadNeighbors Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=5009&pm=2402\r\n* **FlowerGarden Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=5006&pm=1918\r\n* **AvoidRoads Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4709&pm=1889\r\n* **ChessMetric Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4482&pm=1592\r\n* **Jewelry Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4705&pm=1166\r\n* **StripePainter Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4555&pm=1215\r\n* **QuickSums Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=5072&pm=2829\r\n* **ShortPalindromes Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4630&pm=1861\r\n* **StarAdventure Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=5854&pm=2940\r\n* **MiniPonit Problem** :\r\nhttp://www.topcoder.com/tc?module=ProblemDetail&rd=4710&pm=1996\r\n\r\n\r\n Tree Dp :\r\nProblem: given a tree, color nodes black as many as possible without coloring two adjacent nodes\r\n Subproblems:\r\n First, we arbitrarily decide the root node ùëü\r\n ùêµùë£: the optimal solution for a subtree having ùë£ as the root, where we color ùë£ black\r\nùëäùë£: the optimal solution for a subtree having ùë£ as the root, where we don‚Äôt color ùë£\r\nThe answer is max ùêµùëü,ùëäùëü\r\n\r\nBase case : Leaf\r\n\r\n Subset DP :\r\nProb: given a weighted graph with ùëõ nodes, find \r\nthe shortest path that visits every node exactly once \r\n(Traveling Salesman Problem)\r\n\r\nBrute force : O(n!)\r\nDP\t\t\t: O(pow(n,2)*pow(2,n))\r\nD(g,v)=min(D(g-{v},u)+cost(u,v))\r\n\r\n\r\n\r\n####UFPT Mega Dynamic Programming List\r\n\r\nMost straightforward:\r\nhttp://www.spoj.com/problems/COINS/ \r\n```java\r\nstatic HashMap<Integer, Long> hm;\r\n\r\n\tpublic static long coinsT(int i) {\r\n\thm = new HashMap<Integer, Long>();\r\n\t\tif (i < 12) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\r\n\t\tif (hm.containsKey(i)) {\r\n\t\t\treturn hm.get(i);\r\n\t\t}\r\n\t\tlong temp = coinsT(i / 2) + coinsT(i / 3) + coinsT(i / 4);\r\n\t\thm.put(i, temp);\r\n\t\treturn temp;\r\n\t}\r\n\r\n```\r\n                                     \r\n\r\nMore straightforward:\r\nhttp://www.spoj.com/problems/ACODE/     RECOMMENDED        \r\nhttp://www.spoj.com/problems/MIXTURES/  RECOMMENDED                                              \r\nhttp://www.spoj.com/problems/MBALL                                  \r\nhttp://www.spoj.com/problems/PARTY                                  \r\nhttp://www.spoj.com/problems/KNAPSACK/\r\nhttp://www.spoj.com/problems/MKBUDGET\r\nhttp://www.spoj.com/problems/PIGBANK\r\nhttp://www.spoj.com/problems/MMAXPER                                \r\nhttp://www.spoj.com/problems/SCUBADIV/                             \r\nhttp://www.spoj.com/problems/MINVEST\r\nhttp://www.spoj.com/problems/BYTESM2/\r\nhttp://www.spoj.com/problems/ROCK/                                  \r\nhttp://www.spoj.com/problems/NY10E/\r\n \r\nhttp://www.spoj.com/problems/BABTWR/\r\nhttp://www.spoj.com/problems/SQRBR/\r\nhttp://www.spoj.com/problems/TWENDS/\r\nhttp://www.spoj.com/problems/M3TILE/\r\nhttp://www.spoj.com/problems/LISA/\r\nhttp://www.spoj.com/problems/TRT/         NEW\r\n \r\nGraph DP\r\nhttp://www.spoj.com/problems/EDIST/                                  \r\nhttp://www.spoj.com/problems/CSTREET/\r\nhttp://www.spoj.com/problems/CHICAGO/                               \r\nhttp://www.spoj.com/problems/ACPC10D/\r\nhttp://www.spoj.com/problems/DSUBSEQ/\r\nhttp://www.spoj.com/problems/TAP2013J     NEW\r\n \r\n \r\nMediumish:\r\nhttp://www.spoj.com/problems/JOCHEF/\r\nhttp://www.spoj.com/problems/ACMAKER/\r\nhttp://www.spoj.com/problems/MCOINS/\r\nhttp://www.spoj.com/problems/CHOCOLA/\r\nhttp://www.spoj.com/problems/MPILOT\r\nhttp://www.spoj.com/problems/MENU/\r\nhttp://www.spoj.com/problems/CRSCNTRY\r\nhttp://www.spoj.com/problems/MBLAST/\r\nhttp://www.spoj.com/problems/ANARC07G/\r\nhttp://www.spoj.com/problems/IKEYB/\r\nhttp://www.spoj.com/problems/PONY2/       NEW (do ACODE first)\r\nhttp://www.spoj.com/problems/PONY9/       NEW\r\n \r\n \r\nHard:\r\nhttp://www.spoj.com/problems/NGON\r\nhttp://www.spoj.com/problems/MYSTIC/\r\nhttp://www.spoj.com/problems/MSTRING\r\nhttp://www.spoj.com/problems/CHOCDIST\r\nhttp://www.spoj.com/problems/GOSTONES     NEW\r\n\r\nTree:\r\n----------------\r\nhttp://www.spoj.com/problems/PT07Y\r\n\r\nhttp://www.spoj.com/problems/TUTBFS\r\nhttp://www.spoj.com/problems/PT07Y\r\nhttp://www.spoj.com/problems/UCV2013H\r\nhttp://www.spoj.com/problems/LABYR1\r\nhttp://www.spoj.com/problems/SHOP\r\nhttp://www.spoj.com/problems/BYTESE1\r\nhttp://www.spoj.com/problems/BITMAP\r\nhttp://www.spoj.com/problems/PT07Z\r\n\r\n\r\nTO DO:\r\n-------\r\nbasic:\r\n\r\nhttp://www.spoj.com/problems/FCTRL/\r\nhttp://www.spoj.com/problems/BSEARCH1/\r\nhttp://www.spoj.com/problems/HANGOVER/\r\nhttp://www.spoj.com/problems/PALIN/\r\nspoj.com/problems/TEST\r\nspoj.com/problems/ADDREV\r\nspoj.com/problems/PRIME1\r\n\r\nhttp://www.spoj.com/problems/ANARC09C/\r\n\r\nfor disjoint sets\r\nhttp://goo.gl/e9h857\r\nhttp://goo.gl/orqp9H\r\n\r\n\r\n* suffix tree,suffix array\r\n* segment tree(intialize and use for range minimum query problem \r\n\tresult in O(N) prepocessing and O(log(N)) query processing \r\n\r\n\r\n\r\nfinding median in unsorted array :\r\n\r\nhttp://discuss.codechef.com/questions/1489/find-median-in-an-unsorted-array-without-sorting-it\r\n","google":"UA-56646022-1","note":"Don't delete this file! It's used internally to help with page regeneration."}