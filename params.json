{"name":"pknelakuditi.GitHub.io","tagline":"","body":"##Breadth First Search : \r\n\r\n* **using QUEUE** :\r\n\r\n```java\r\nq.add(start);\r\nvisited[start] = true;\r\n\t\twhile (!q.isEmpty()) {\r\n\t\t\tint temp = q.remove();\r\n\t\t\tfor (int i = 0; i < graph.get(temp).size(); i++) {\r\n\t\t\t\tif (!visited[i]) {\r\n\t\t\t\t\tvisited[i] = true;\r\n\t\t\t\t\tq.add(i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\t\t\r\n``` \t\t\r\n\r\n##Depth First Search\r\n\r\n* **using stack** :\r\n\r\n```java\r\n\r\npublic static void dfs(ArrayList<ArrayList<Integer>> graph,int start){\r\nq.add(start);\r\nvisited[start] = true;\r\n\t\twhile(!s.isEmpty()){\r\n\t\t\tint temp=s.pop();\r\n\t\t\tArrayList<Integer> neighbours=graph.get(temp);\r\n\t\t\tfor(int n:neighbours){\r\n\t\t\t\tif(!visited[n]){\r\n\t\t\t\t\ts.add(n);\r\n\t\t\t\t\tvisited[n]=true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n}\r\n\r\n```\r\n\r\n##Dijkstra's Algorithm \r\n\r\n\r\n```java  \r\n\r\npublic static int dijkstras(Vertex[] graph, int source, int destination) {\r\n        boolean[] visited =new boolean[graph.length];\r\n\t\tVertex current = graph[source];\r\n\t\t\r\n\t\tPriorityQueue<Vertex> pq = new PriorityQueue<Vertex>();\r\n\t\t//intially minDistance for each vertex would be Integer.MAXVALUE make start distance as zero\r\n        current.minDistance=0;\r\n\t\tpq.add(current);\r\n\t\twhile (!pq.isEmpty()) {\r\n\t\t\tcurrent = pq.remove();\r\n\t\t\tif (current.id == destination) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif(visited[current.id]){\r\n\t\t\t\tcontinue;\r\n\t\t\t}else{\r\n\t\t\t\tvisited[current.id]=true;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t//updating all the unvisited new neighbour values  and insert in pq\r\n\t\t\tfor (Edge e : current.neighbors) {\r\n\t\t\t\tif((visited[e.end])){continue;}\r\n\t\t\t\tVertex end = graph[e.end];\r\n\t\t\t\tint distance = e.distance;\r\n\t\t\t\tint newMin = distance + current.minDistance;\r\n\t\t\t\tif (newMin < end.minDistance  ) {\r\n\t\t\t\t\tend.minDistance = newMin;\r\n\t\t\t\t\tpq.add(end);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn graph[destination].minDistance;\t\t\r\n\t\t\r\n\t}\r\n```\r\n\r\n##Prim's Algorithm\r\n\r\n```java\r\n\tprivate static int PrimsAlgorithm(Vertex[] graph, int source) {\r\n\t\tPriorityQueue<Edge> pq=new PriorityQueue<Edge>();\r\n\t\tboolean[] visited=new boolean[graph.length];\r\n\t\r\n\t\tint cost=0;\r\n\t\t\r\n\t\tvisited[source]=true;\r\n\t\tfor(Edge e:graph[source].neighbors){\r\n\t\t\tpq.add(e);\r\n\t\t}\r\n\t\t\r\n\t\twhile(!pq.isEmpty()){\r\n\t\t\tEdge current=pq.remove();\r\n\t\t\r\n\t\t\tif(visited[current.edge]){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvisited[current.edge]=true;\r\n\t\t\tcost=cost+current.cost;\r\n\t\t\t//adding all the unvisited neoghbours into the priority pq\r\n\t\t\tfor(Edge e:graph[current.edge].neighbors){\r\n\t\t\t\tif(visited[e.edge]){\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tpq.add(e);\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn cost;\r\n\t}\r\n```\r\n##Kruskal's algo : \r\ncomparable on the cost of edge and put it pq and add the edges into MST when only it results in union of two different sets.\r\n\r\ntaking care of disjoint sets:\r\n```java\r\npublic static class DisjointSets {\r\n\t\tint[] parents;\r\n\r\n\t\tpublic DisjointSets(int size) {\r\n\t\t\tparents = new int[size];\r\n\t\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\t\tparents[i] = i;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tpublic int find(int x) {\r\n\t\t\tif (parents[x] == x) {\r\n                return x;\r\n\t\t\t}else{\r\n\t\t\t\tparents[x]=find(parents[x]);\r\n\t\t\t\treturn parents[x];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpublic void union(int x,int y){\r\n\t\t\tparents[find(x)]=find(y);\r\n\t\t}\r\n\r\n\t}\r\n```\r\nadd all the edges to pq and send it as parameter for function\r\n```java\r\nprivate static int kruskals(PriorityQueue<Edge> pq, int v) {\r\n\t\tDisjointSets ds=new DisjointSets(v);\r\n\t\tEdge current;\r\n\t\tint components=v;\r\n\t\tint cost=0;\r\n\t\twhile(!pq.isEmpty()){\r\n\t\t\tcurrent=pq.remove();\r\n\t\t\tif(ds.find(current.edge)==ds.find(current.oEdge)){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tcomponents--;\r\n\t\t\tds.union(current.edge,current.oEdge);\r\n\t\t\tcost+=current.cost;\r\n\t\t}\r\n\t\tif(components>1){\r\n\t\t\treturn -1;\r\n\t\t}else{\r\n\t\t\treturn cost;\r\n\t\t}\r\n\t\t\r\n\t}\r\n```\r\n##Range Minimum Query (RMQ)\r\n--------------------------\r\ndescription: on arrays to find the position of an element with the minimum value between two specified indices.\r\n\r\nAlgo:\r\n preprocess sqrt(N) segment minimums\r\n range given then 2 half participated and remaining all full participated segments.\r\n* preprocess: O(N)\r\n* range query : O(sqrt(N))\r\n\r\nwhen update(i,X)\r\nthen calculate min for inserted segment O(sqrt(N))\r\n\r\n##Least commom ansestor \r\n-----------------------\r\ndesc : can be reduced to a restricted version of an RMQ problem, in which consecutive array elements differ by exactly 1.\r\n\r\npreprocessing:O(N)\r\ndivide into sqrt(h) height segments make each element in the segment point to the least ancestor in the next height segment.\r\nquery:O(log(N))\r\nlca(a,b)\r\nthen check the height segment of the nodes and make min of them jump segmnts till it reaches the the other by moving up to its parents similar to previous problem then \r\n\r\nif both parent for next height segment values are same then start moving up the in the same height segment one after another by comparing both of their parents \r\nelse move both pointers to next height segment to their resoectice parents\r\n\r\n\r\nother algo : write inorder of the tree and find minimum in range of tree index [a,b] . \r\n\r\ntry coding it\r\n```java\r\nstruct Node *findLCA(struct Node* root, int n1, int n2)\r\n{\r\n   \r\n   if (root == NULL) return NULL; \r\n   if (root->key == n1 || root->key == n2)\r\n        return root;\r\n    \r\n    Node *left_lca  = findLCA(root->left, n1, n2);\r\n    Node *right_lca = findLCA(root->right, n1, n2);\r\n \r\n   if (left_lca && right_lca)  return root;\r\n \r\n     return (left_lca != NULL)? left_lca: right_lca;\r\n}\r\n```\r\n\r\nproblems:\r\nhttp://www.spoj.com/problems/LCASQ/\r\nhttp://www.spoj.com/problems/RMQSQ/\r\nhttp://www.spoj.com/problems/LCA/\r\n\r\n\r\nresource:\r\nhttp://help.topcoder.com/data-science/competing-in-algorithm-challenges/algorithm-tutorials/range-minimum-query-and-lowest-common-ancestor/\r\n\r\n##Range Sum Query:\r\n-----------------\r\na[] =original array\r\nb[] =cumative sum array\r\n\r\nget an array which have sum of all the b[i]=b[i-1]+a[i]\r\n\r\n\r\n* preprocessing : o(N) \r\n* query: b[j]-b[i-1]  o(1)\r\n* update: o(N)\r\n\r\ncan be done better by using:\r\n \t**Fenwick tree or binary indexed tree**\r\n \t\r\n \tleast significant bit of x = x & -x\r\n \t-x = !x + 1 \r\n \t\r\n \t\r\n```java\t\r\nclass BIT {\r\n\tint[] tree;\r\n\tpublic BIT(int n) {\r\n\t\tthis.tree = new int[n];\r\n\t}\r\n\tint lsb(int x) {\r\n\t\treturn x & -x;\r\n\t}\r\n\tvoid update(int i, int x) {\r\n\t\twhile (i <= tree.length-1) {\r\n\t\t\ttree[i] += x;\r\n\t\t\ti += lsb(i);\r\n\t\t}\r\n\t}\r\n\tint query(int i) {\r\n\t\tint sum = 0;\r\n\t\twhile (i > 0) {\r\n\t\t\tsum += tree[i];\r\n\t\t\ti -= lsb(i);\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n}\r\n```\r\n \t\r\nhttp://community.topcoder.com/tc?module=Static&d1=tutorials&d2=binaryIndexedTrees\r\nhttp://pdf.aminer.org/001/073/976/a_new_data_structure_for_cumulative_frequency_tables.pdf  \r\n\r\n\r\n\r\nTO DO:\r\n-------\r\nbasic:\r\n\r\nhttp://www.spoj.com/problems/FCTRL/\r\nhttp://www.spoj.com/problems/BSEARCH1/\r\nhttp://www.spoj.com/problems/HANGOVER/\r\nhttp://www.spoj.com/problems/PALIN/\r\nspoj.com/problems/TEST\r\nspoj.com/problems/ADDREV\r\nspoj.com/problems/PRIME1\r\n\r\nhttp://www.spoj.com/problems/ANARC09C/\r\n\r\nfor disjoint sets\r\nhttp://goo.gl/e9h857\r\nhttp://goo.gl/orqp9H\r\n\r\n\r\n* suffix tree,suffix array\r\n* segment tree(intialize and use for range minimum query problem \r\n\tresult in O(N) prepocessing and O(log(N)) query processing \r\n\r\n\r\n\r\nfinding median in unsorted array :\r\n\r\nhttp://discuss.codechef.com/questions/1489/find-median-in-an-unsorted-array-without-sorting-it\r\n\r\nUFPT Mega Dynamic Programming List\r\n---------------------------------------------------------------------\r\nMost straightforward:\r\nhttp://www.spoj.com/problems/COINS/                                      \r\n\r\nMore straightforward:\r\nhttp://www.spoj.com/problems/MBALL                                  \r\nhttp://www.spoj.com/problems/PARTY                                  \r\nhttp://www.spoj.com/problems/KNAPSACK/\r\nhttp://www.spoj.com/problems/MKBUDGET\r\nhttp://www.spoj.com/problems/PIGBANK\r\nhttp://www.spoj.com/problems/MMAXPER                                \r\nhttp://www.spoj.com/problems/SCUBADIV/                             \r\nhttp://www.spoj.com/problems/MINVEST\r\nhttp://www.spoj.com/problems/ACODE/     RECOMMENDED                 \r\nhttp://www.spoj.com/problems/BYTESM2/\r\nhttp://www.spoj.com/problems/MIXTURES/  RECOMMENDED                                     \r\nhttp://www.spoj.com/problems/ROCK/                                  \r\nhttp://www.spoj.com/problems/NY10E/\r\n \r\nhttp://www.spoj.com/problems/BABTWR/\r\nhttp://www.spoj.com/problems/SQRBR/\r\nhttp://www.spoj.com/problems/TWENDS/\r\nhttp://www.spoj.com/problems/M3TILE/\r\nhttp://www.spoj.com/problems/LISA/\r\nhttp://www.spoj.com/problems/TRT/         NEW\r\n \r\nGraph DP\r\nhttp://www.spoj.com/problems/EDIST/                                  \r\nhttp://www.spoj.com/problems/CSTREET/\r\nhttp://www.spoj.com/problems/CHICAGO/                               \r\nhttp://www.spoj.com/problems/ACPC10D/\r\nhttp://www.spoj.com/problems/DSUBSEQ/\r\nhttp://www.spoj.com/problems/TAP2013J     NEW\r\n \r\n \r\nMediumish:\r\nhttp://www.spoj.com/problems/JOCHEF/\r\nhttp://www.spoj.com/problems/ACMAKER/\r\nhttp://www.spoj.com/problems/MCOINS/\r\nhttp://www.spoj.com/problems/CHOCOLA/\r\nhttp://www.spoj.com/problems/MPILOT\r\nhttp://www.spoj.com/problems/MENU/\r\nhttp://www.spoj.com/problems/CRSCNTRY\r\nhttp://www.spoj.com/problems/MBLAST/\r\nhttp://www.spoj.com/problems/ANARC07G/\r\nhttp://www.spoj.com/problems/IKEYB/\r\nhttp://www.spoj.com/problems/PONY2/       NEW (do ACODE first)\r\nhttp://www.spoj.com/problems/PONY9/       NEW\r\n \r\n \r\nHard:\r\nhttp://www.spoj.com/problems/NGON\r\nhttp://www.spoj.com/problems/MYSTIC/\r\nhttp://www.spoj.com/problems/MSTRING\r\nhttp://www.spoj.com/problems/CHOCDIST\r\nhttp://www.spoj.com/problems/GOSTONES     NEW\r\n\r\nTree:\r\n----------------\r\nhttp://www.spoj.com/problems/PT07Y\r\n\r\nhttp://www.spoj.com/problems/TUTBFS\r\nhttp://www.spoj.com/problems/PT07Y\r\nhttp://www.spoj.com/problems/UCV2013H\r\nhttp://www.spoj.com/problems/LABYR1\r\nhttp://www.spoj.com/problems/SHOP\r\nhttp://www.spoj.com/problems/BYTESE1\r\nhttp://www.spoj.com/problems/BITMAP\r\nhttp://www.spoj.com/problems/PT07Z\r\n","google":"UA-56646022-1","note":"Don't delete this file! It's used internally to help with page regeneration."}